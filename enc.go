// package goenc contains functions for working with encryption
// work is derived from many sources:
//
// http://stackoverflow.com/questions/21151714/go-generate-an-ssh-public-key
// https://github.com/andmarios/golang-nacl-secretbox
// https://golang.org/pkg/crypto/cipher/

package goenc

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"io"

	"bytes"

	"io/ioutil"

	"fmt"

	"golang.org/x/crypto/nacl/secretbox"
	"golang.org/x/crypto/ssh"
)

/*
	TODO(cmc) - Add encrypted private key decryption
	TODO(cmc) - Support loading and parsing private/public keys from different formats
	TODO(cmc) - Finish writing tests
	TODO(cmc) - Verify this isn't horrifically insecure

*/

const (
	keySize = 32
)

// Decrypt decrypts ciphertext using the given key
func Decrypt(ciphertext, key []byte) ([]byte, error) {

	// Create the AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	if len(ciphertext) < aes.BlockSize {
		return nil, errors.New("Ciphertext is shorter than aes.BlockSize")
	}

	// get first 16 bytes from ciphertext
	iv := ciphertext[:aes.BlockSize]

	// Remove the IV from the ciphertext
	ciphertext = ciphertext[aes.BlockSize:]

	// Return a decrypted stream
	stream := cipher.NewCFBDecrypter(block, iv)

	// Decrypt bytes from ciphertext
	stream.XORKeyStream(ciphertext, ciphertext)

	return ciphertext, nil
}

// Encrypt encrypts ciphertext using the given key.
// NOTE: This is not secure without being authenticated (crypto/hmac)
func Encrypt(plaintext, key []byte) ([]byte, error) {
	// Create the AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	// Empty array of 16 + plaintext length
	// Include the IV at the beginning
	ciphertext := make([]byte, aes.BlockSize+len(plaintext))

	// Slice of first 16 bytes
	iv := ciphertext[:aes.BlockSize]

	// Write 16 rand bytes to fill iv
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return nil, err
	}

	// Return an encrypted stream
	stream := cipher.NewCFBEncrypter(block, iv)

	// Encrypt bytes from plaintext to ciphertext
	stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
	return ciphertext, nil
}

// DecryptString decrypts ciphertext using the given key
func DecryptString(ciphertext, key string) (string, error) {
	b, err := Decrypt([]byte(ciphertext), []byte(key))
	return string(b), err
}

// EncryptString encrypts ciphertext using the given key
func EncryptString(plaintext, key string) (string, error) {
	b, err := Encrypt([]byte(plaintext), []byte(key))
	return string(b), err
}

// SSHKeyPair generates private and public key bytes
func SSHKeyPair() (privateKeyBytes, publicKeyBytes []byte, err error) {
	privateKey, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		return nil, nil, err
	}
	buf := bytes.NewBuffer(privateKeyBytes)
	privateKeyPEM := &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)}
	if err = pem.Encode(buf, privateKeyPEM); err != nil {
		return nil, nil, err
	}

	// generate and write public key
	pub, err := ssh.NewPublicKey(&privateKey.PublicKey)
	if err != nil {
		return nil, nil, err
	}
	publicKeyBytes = ssh.MarshalAuthorizedKey(pub)
	return
}

// GenerateAndSaveSSHKeyPair generates a new ssh private key and public key and saves them to the given paths
func GenerateAndSaveSSHKeyPair(privateKeyPath, pubkeyPath string) error {
	pr, pub, err := SSHKeyPair()
	if err != nil {
		return err
	}
	if err := ioutil.WriteFile(privateKeyPath, pr, 0600); err != nil {
		return err
	}
	return ioutil.WriteFile(pubkeyPath, pub, 0644)
}

const (
	nonceSize = 24
)

// NaCLEncrypt salts a key using pad and encrypts a message
func NaCLEncrypt(pad, key, message []byte) (out []byte, err error) {
	if len(pad) == 0 {
		return nil, errors.New("pad had a length of 0, it must be at least 32 bytes")
	}
	// NaCl's key has a constant size of 32 bytes.
	// The user provided key probably is less than that. We pad it with
	// a long enough string and truncate anything we don't need later on.
	key = append(key, pad...)

	// NaCl's key should be of type [32]byte.
	// Here we create it and truncate key bytes beyond 32
	naclKey := new([keySize]byte)
	copy(naclKey[:], key[:keySize])

	// Nonce is a [24]byte variable that should be unique amongst messages.
	// Nonce is generated by the encrypter.
	// 24 bytes is large enough to avoid collisions while reading from rand.
	// If it suits you better, you may use a non random nonce (e.g a counter).
	// It only has to change per message.
	nonce := new([nonceSize]byte)
	// Read bytes from random and put them in nonce until it is full.
	_, err = io.ReadFull(rand.Reader, nonce[:])
	if err != nil {
		return nil, fmt.Errorf("Could not read from random: %s", err)
	}
	// out will hold the nonce and the encrypted message (ciphertext)
	out = make([]byte, nonceSize)
	// Copy the nonce to the start of out
	copy(out, nonce[:])
	// Encrypt the message and append it to out, assign the result to out
	out = secretbox.Seal(out, message, nonce, naclKey)
	return out, err
}

// NaCLDecrypt salts a key using pad and decrypts a message
func NaCLDecrypt(pad, key, data []byte) (out []byte, err error) {
	key = append(key, pad...)

	// NaCl's key should be of type [32]byte.
	// Here we create it and truncate key bytes beyond 32
	naclKey := new([keySize]byte)
	copy(naclKey[:], key[:keySize])

	// The nonce is of type [24]byte and part of the data we will receive
	nonce := new([nonceSize]byte)

	// Read the nonce from in, it is in the first 24 bytes
	copy(nonce[:], data[:nonceSize])

	// Decrypt the output of secretbox.Seal which contains the nonce and
	// the encrypted message
	message, ok := secretbox.Open(nil, data[nonceSize:], nonce, naclKey)
	if ok {
		return message, nil
	}
	return nil, errors.New("Decryption failed")
}
